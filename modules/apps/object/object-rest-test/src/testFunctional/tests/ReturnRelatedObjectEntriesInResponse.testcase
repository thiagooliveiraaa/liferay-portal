@component-name = "portal-headless"
definition {

	property custom.properties = "feature.flag.LPS-153117=true${line.separator}feature.flag.LPS-165819=true";
	property portal.release = "true";
	property portal.upstream = "true";
	property testray.component.names = "Object";
	property testray.main.component.name = "Headless";

	setUp {
		TestCase.setUpPortalInstanceNoSelenium();

		task ("Given two custom objects created and published") {
			var studentObjectDefinitionId = ObjectDefinitionAPI.createAndPublishObjectDefinition(
				en_US_label = "student",
				en_US_plural_label = "students",
				name = "Student",
				requiredStringFieldName = "name");
			var subjectObjectDefinitionId = ObjectDefinitionAPI.createAndPublishObjectDefinition(
				en_US_label = "subject",
				en_US_plural_label = "subjects",
				name = "Subject",
				requiredStringFieldName = "name");
		}

		task ("And Given a many-to-many studentsSubjects relationship created between them being Student the parent") {
			ObjectDefinitionAPI.createRelationship(
				deletionType = "cascade",
				en_US_label = "studentsSubjects",
				name = "studentsSubjects",
				objectDefinitionId1 = ${studentObjectDefinitionId},
				objectDefinitionId2 = ${subjectObjectDefinitionId},
				type = "manyToMany");
		}

		task ("And Given a one-to-many mainSubjectStudents relationship created between them being Subject the parent") {
			ObjectDefinitionAPI.createRelationship(
				deletionType = "cascade",
				en_US_label = "mainSubjectStudents",
				name = "mainSubjectStudents",
				objectDefinitionId1 = ${subjectObjectDefinitionId},
				objectDefinitionId2 = ${studentObjectDefinitionId},
				type = "oneToMany");
		}

		task ("And Given a one-to-many mainSubjects relationship created between Subject and itself") {
			ObjectDefinitionAPI.createRelationship(
				deletionType = "cascade",
				en_US_label = "mainSubjects",
				name = "mainSubjects",
				objectDefinitionId1 = ${subjectObjectDefinitionId},
				objectDefinitionId2 = ${subjectObjectDefinitionId},
				type = "oneToMany");
		}

		task ("And Given a many-to-many studentsUsers relationship created between them being Student the parent") {
			var systemUserObjectId = ObjectDefinitionAPI.getObjectDefinitionIdByName(name = "User");

			ObjectDefinitionAPI.createRelationship(
				deletionType = "cascade",
				en_US_label = "studentsUsers",
				name = "studentsUsers",
				objectDefinitionId1 = ${studentObjectDefinitionId},
				objectDefinitionId2 = ${systemUserObjectId},
				type = "manyToMany");
		}

		task ("And Given a one-to-many studentUsers relationship created between them being Student the parent") {
			ObjectDefinitionAPI.createRelationship(
				deletionType = "cascade",
				en_US_label = "studentUsers",
				name = "studentUsers",
				objectDefinitionId1 = ${studentObjectDefinitionId},
				objectDefinitionId2 = ${systemUserObjectId},
				type = "oneToMany");
		}

		task ("And Given a many-to-many usersStudents relationship created between them being User the parent") {
			ObjectDefinitionAPI.createRelationship(
				deletionType = "cascade",
				en_US_label = "usersStudents",
				name = "usersStudents",
				objectDefinitionId1 = ${systemUserObjectId},
				objectDefinitionId2 = ${studentObjectDefinitionId},
				type = "manyToMany");
		}

		task ("And Given a one-to-many userStudents relationship created between them being User the parent") {
			ObjectDefinitionAPI.createRelationship(
				deletionType = "cascade",
				en_US_label = "userStudents",
				name = "userStudents",
				objectDefinitionId1 = ${systemUserObjectId},
				objectDefinitionId2 = ${studentObjectDefinitionId},
				type = "oneToMany");
		}
	}

	tearDown {
		var testPortalInstance = PropsUtil.get("test.portal.instance");

		ObjectAdmin.deleteAllCustomObjectsViaAPI();

		JSONUser.tearDownNonAdminUsersNoSelenium();

		if (${testPortalInstance} == "true") {
			PortalInstances.tearDownCP();
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnChildAndParentsWithPostChildStudentInManyToManyRelationship {
		property portal.acceptance = "true";

		task ("When with postStudent to create a student and two related users") {
			var response = CustomObjectAPI.createObjectEntryAndRelatedObjects(
				alternateName = "user",
				emailDomain = "liferay.com",
				en_US_plural_label = "students",
				familyName = "userfn",
				fieldName = "name",
				fieldValue = "Bob",
				givenName = "usergn",
				nestedField = "usersStudents",
				numberOfRelatedObjectEntries = 2,
				relatedUserAccount = "true");
		}

		task ("Then in response I can retrieve detailed information of the newly created student and users in usersStudents") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "Bob",
				objectJsonPath = "$.name",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "user1,user2",
				objectJsonPath = "$.usersStudents[*].alternateName",
				response = ${response});
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnChildAndParentsWithPostChildSubjectInManyToManyRelationship {
		property portal.acceptance = "true";

		task ("When creating Subject with postSubject and two related Students in studentsSubjects") {
			var response = CustomObjectAPI.createObjectEntryAndRelatedObjects(
				en_US_plural_label = "subjects",
				fieldName = "name",
				fieldValue = "Math",
				nestedField = "studentsSubjects",
				numberOfRelatedObjectEntries = 2,
				relatedEntryFieldName = "name");
		}

		task ("Then in response I can retrieve detailed information of subject and two students in studentsSubjects") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "Math",
				objectJsonPath = "$.name",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "name0,name1",
				objectJsonPath = "$.studentsSubjects[*].name",
				response = ${response});
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnChildAndParentWithPostChildUserInManyToManyRelationship {
		property portal.acceptance = "true";

		task ("When with postUserAccount to create a userAccount and two related students") {
			var response = UserAccountAPI.createUserAccountAndRelatedObjects(
				alternateName = "user1",
				emailAddress = "user1@liferay.com",
				familyName = "user1fn",
				givenName = "user1gn",
				nestedField = "studentsUsers",
				numberOfRelatedObjectEntries = 2,
				relatedEntryFieldName = "name");
		}

		task ("Then in response I can retrieve detailed information of the newly created user and two students in studentsUsers") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "user1",
				objectJsonPath = "$.alternateName",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "name0,name1",
				objectJsonPath = "$.studentsUsers[*].name",
				response = ${response});
		}
	}

	@description = "Ignore tests unitl LPS-184670 fixed"
	@disable-webdriver = "true"
	@ignore = "true"
	@priority = 4
	test CanReturnChildAndParentWithPostChildUserInOneToManyRelationship {
		property portal.acceptance = "true";

		task ("When with postUserAccount to create a user and a related student") {
			var response = UserAccountAPI.createUserAccountAndRelatedObjects(
				alternateName = "user",
				emailAddress = "user@liferay.com",
				familyName = "userfn",
				givenName = "usergn",
				nestedField = "studentUsers",
				numberOfRelatedObjectEntries = 1,
				oneToManyChild = "true",
				relatedEntryFieldName = "name");
		}

		task ("Then in response I can retrieve detailed information of the newly created user and related student") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "user",
				objectJsonPath = "$.alternateName",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "name0",
				objectJsonPath = "$.studentUsers.name",
				response = ${response});
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnChildAndSystemParentWithPostChildStudentInOneToManyRelationship {
		property portal.acceptance = "true";

		task ("When with postStudent to create a student and one related user") {
			var response = CustomObjectAPI.createObjectEntryAndRelatedObjects(
				alternateName = "user",
				emailDomain = "liferay.com",
				en_US_plural_label = "students",
				familyName = "userfn",
				fieldName = "name",
				fieldValue = "Bob",
				givenName = "usergn",
				nestedField = "userStudents",
				numberOfRelatedObjectEntries = 1,
				oneToManyChild = "true",
				relatedUserAccount = "true");
		}

		task ("Then in response I can retrieve detailed information of the newly created student and user in userStudents") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "Bob",
				objectJsonPath = "$.name",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "user1",
				objectJsonPath = "$.userStudents.alternateName",
				response = ${response});
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnCustomObjectsWithPostSubjectInManyToOneRelationshipWithItself {
		property portal.acceptance = "true";

		task ("When with postSubject to create a subject including a related subject in mainSubjects{}") {
			var response = CustomObjectAPI.createObjectEntryAndRelatedObjects(
				en_US_plural_label = "subjects",
				fieldName = "name",
				fieldValue = "Math",
				nestedField = "mainSubjects",
				numberOfRelatedObjectEntries = 1,
				oneToManyChild = "true",
				relatedEntryFieldName = "name");
		}

		task ("Then in response I can retrieve detailed information of subject and its related subject") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "Math",
				objectJsonPath = "$.name",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "name0",
				objectJsonPath = "$.mainSubjects[*].name",
				response = ${response});
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnUpdatedChildAndParentsWithPatchChildStudentInManyToManyRelationship {
		property portal.acceptance = "true";

		task ("And Given with postStudent to create a student and two related users") {
			var response = CustomObjectAPI.createObjectEntryAndRelatedObjects(
				alternateName = "user",
				emailDomain = "liferay.com",
				en_US_plural_label = "students",
				familyName = "userfn",
				fieldName = "name",
				fieldValue = "Bob",
				givenName = "usergn",
				nestedField = "usersStudents",
				numberOfRelatedObjectEntries = 2,
				relatedUserAccount = "true");
		}

		task ("When with patchStudent and studentId to update the existing student including usersStudents with a new user and an existing user with its externalReferenceCode") {
			var studentId = JSONPathUtil.getIdValue(response = ${response});
			var userExternalReferenceCodes = JSONUtil.getWithJSONPath(${response}, "$.usersStudents[*].externalReferenceCode");

			var response = CustomObjectAPI.updateObjectEntryAndRelatedObjectsByPut(
				alternateName = "user",
				emailDomain = "liferay.com",
				en_US_plural_label = "students",
				familyName = "userfn",
				fieldName = "name",
				fieldValue = "Bob-update",
				givenName = "usergn",
				nestedField = "usersStudents",
				objectEntryId = ${studentId},
				relatedUserAccount = "true",
				userExternalReferenceCodes = "${userExternalReferenceCodes},newErc");
		}

		task ("Then in response I can retrieve detailed information of the updated student and three related users in usersStudents") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "Bob-update",
				objectJsonPath = "$.name",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "user1-update,user2-update,user3-update",
				objectJsonPath = "$.usersStudents[*].alternateName",
				response = ${response});
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnUpdatedChildAndParentsWithPatchChildUserInManyToManyRelationship {
		property portal.acceptance = "true";

		task ("And Given with postUserAccount to create a userAccount and two related students") {
			var response = UserAccountAPI.createUserAccountAndRelatedObjects(
				alternateName = "user1",
				emailAddress = "user1@liferay.com",
				familyName = "user1fn",
				givenName = "user1gn",
				nestedField = "studentsUsers",
				numberOfRelatedObjectEntries = 2,
				relatedEntryExternalReferenceCode = "studentErc",
				relatedEntryFieldName = "name");
		}

		task ("When with patchUserAccount and userAccountId to update the existing user including studentsUsers with a new student and an existing student with its externalReferenceCode") {
			var userAccountId = JSONPathUtil.getIdValue(response = ${response});

			var response = UserAccountAPI.partialUpdateUserAccountAndRelatedObjects(
				emailAddress = "userpartiallyupdated@liferay.com",
				nestedField = "studentsUsers",
				numberOfRelatedObjectEntries = 3,
				relatedEntryExternalReferenceCode = "studentErc",
				relatedEntryFieldName = "name",
				userAccountId = ${userAccountId});
		}

		task ("Then in repsonse I can retrieve detailed information of the updated user and three related students") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "userpartiallyupdated@liferay.com",
				objectJsonPath = "$.emailAddress",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "name0-update,name1-update,name2-update",
				objectJsonPath = "$.studentsUsers[*].name",
				response = ${response});
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnUpdatedChildAndParentWithPatchChildStudentInOneToManyRelationship {
		property portal.acceptance = "true";

		task ("And Given with postSubject I create one subject and two related students in one request") {
			var response = CustomObjectAPI.createObjectEntryAndRelatedObjects(
				en_US_plural_label = "subjects",
				externalReferenceCode = "subjectErc",
				fieldName = "name",
				fieldValue = "Math",
				nestedField = "mainSubjectStudents",
				numberOfRelatedObjectEntries = 2,
				relatedEntryFieldName = "name");
		}

		task ("When with patchStudent and studentId to update the existing student including mainSubjectStudents with updated subject and externalReferenceCode information") {
			var studentId = JSONUtil.getWithJSONPath(${response}, "$.mainSubjectStudents[0].id");

			var response = CustomObjectAPI.updateObjectEntryAndRelatedObjectsByPatch(
				en_US_plural_label = "students",
				fieldName = "name",
				fieldValue = "Able",
				nestedField = "mainSubjectStudents",
				numberOfRelatedObjectEntries = 1,
				objectEntryId = ${studentId},
				oneToManyChild = "true",
				relatedEntryExternalReferenceCode = "subjectErc",
				relatedEntryFieldName = "name");
		}

		task ("Then in response I can retrieve detailed information of the updated student and subject in mainSubjectStudents and r_mainSubjectStudents_c_subject") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "Able",
				objectJsonPath = "$.name",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "name0-update",
				objectJsonPath = "$.r_mainSubjectStudents_c_subject.name",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "name0-update",
				objectJsonPath = "$.mainSubjectStudents.name",
				response = ${response});
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnUpdatedChildAndSystemParentWithPatchChildStudentInOneToManyRelationship {
		property portal.acceptance = "true";

		task ("And Given with postStudent to create a student and one related user") {
			var response = CustomObjectAPI.createObjectEntryAndRelatedObjects(
				alternateName = "user",
				emailDomain = "liferay.com",
				en_US_plural_label = "students",
				familyName = "userfn",
				fieldName = "name",
				fieldValue = "Bob",
				givenName = "usergn",
				nestedField = "userStudents",
				numberOfRelatedObjectEntries = 1,
				oneToManyChild = "true",
				relatedUserAccount = "true");
		}

		task ("When with patchStudent and studentId to update the existing student including userStudents with updated user information and its externalReferenceCode") {
			var studentId = JSONPathUtil.getIdValue(response = ${response});
			var userExternalReferenceCode = JSONUtil.getWithJSONPath(${response}, "$.userStudents.externalReferenceCode");

			var response = CustomObjectAPI.updateObjectEntryAndRelatedObjectsByPatch(
				alternateName = "user",
				emailDomain = "liferay.com",
				en_US_plural_label = "students",
				familyName = "userfn",
				fieldName = "name",
				fieldValue = "Bob-update",
				givenName = "usergn",
				nestedField = "userStudents",
				objectEntryId = ${studentId},
				oneToManyChild = "true",
				relatedUserAccount = "true",
				userExternalReferenceCodes = ${userExternalReferenceCode});
		}

		task ("Then in response I can retrieve detailed infomation of the updated student and user") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "Bob-update",
				objectJsonPath = "$.name",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "user1-update",
				objectJsonPath = "$.userStudents.alternateName",
				response = ${response});
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnUpdatedCustomObjectsWithPatchSubjectInOneToManyRelationshipWithItself {
		property portal.acceptance = "true";

		task ("And Given with postSubject I create a subject and one related subject in one request") {
			var response = CustomObjectAPI.createObjectEntryAndRelatedObjects(
				en_US_plural_label = "subjects",
				fieldName = "name",
				fieldValue = "Math",
				nestedField = "mainSubjects",
				numberOfRelatedObjectEntries = 1,
				oneToManyChild = "true",
				relatedEntryExternalReferenceCode = "subjectErc",
				relatedEntryFieldName = "name");
		}

		task ("When with patchSubject and subjectId to update the existing subject including mainSubjects{} with updated subject name and original externalReferenceCode") {
			var subjectId = JSONPathUtil.getIdValue(response = ${response});

			var response = CustomObjectAPI.updateObjectEntryAndRelatedObjectsByPatch(
				en_US_plural_label = "subjects",
				fieldName = "name",
				fieldValue = "English",
				nestedField = "mainSubjects",
				numberOfRelatedObjectEntries = 1,
				objectEntryId = ${subjectId},
				oneToManyChild = "true",
				relatedEntryExternalReferenceCode = "subjectErc",
				relatedEntryFieldName = "name");
		}

		task ("Then in response I can retrieve detailed information of the updated subjects in mainSubjects and r_mainSubjects_c_subject") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "English",
				objectJsonPath = "$.name",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "name0-update",
				objectJsonPath = "$.mainSubjects[*].name",
				response = ${response});
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnUpdatedParentAndChildrenWithPatchParentStudentInManyToManyRelationship {
		property portal.acceptance = "true";

		task ("And Given with postStudent I created a student and two related subjects in one request") {
			var response = CustomObjectAPI.createObjectEntryAndRelatedObjects(
				en_US_plural_label = "students",
				fieldName = "name",
				fieldValue = "Able",
				nestedField = "studentsSubjects",
				numberOfRelatedObjectEntries = 2,
				relatedEntryExternalReferenceCode = "subjectErc",
				relatedEntryFieldName = "name");
		}

		task ("When with patchStudent and studentId to update the existing student including studentsSubjects with a new subject and two existing subjects with exteralReferenceCode information") {
			var studentId = JSONPathUtil.getIdValue(response = ${response});

			var response = CustomObjectAPI.updateObjectEntryAndRelatedObjectsByPatch(
				en_US_plural_label = "students",
				fieldName = "name",
				fieldValue = "Able-update",
				nestedField = "studentsSubjects",
				numberOfRelatedObjectEntries = 3,
				objectEntryId = ${studentId},
				relatedEntryExternalReferenceCode = "subjectErc",
				relatedEntryFieldName = "name");
		}

		task ("Then in repsonse I can retrieve detailed information of the updated student and three related subjects") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "Able-update",
				objectJsonPath = "$.name",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "name0-update,name1-update,name2-update",
				objectJsonPath = "$.studentsSubjects[*].name",
				response = ${response});
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnUpdatedParentAndChildrenWithPutParentStudentInOneToManyRelationship {
		property portal.acceptance = "true";

		task ("And Given with postStudent to create a student and two related users") {
			var response = CustomObjectAPI.createObjectEntryAndRelatedObjects(
				alternateName = "user",
				emailDomain = "liferay.com",
				en_US_plural_label = "students",
				familyName = "userfn",
				fieldName = "name",
				fieldValue = "Bob",
				givenName = "usergn",
				nestedField = "studentUsers",
				numberOfRelatedObjectEntries = 2,
				relatedUserAccount = "true");
		}

		task ("When with putStudent and studentId to update the existing student including studentUsers with a new user and an existing user with its externalReferenceCode") {
			var studentId = JSONPathUtil.getIdValue(response = ${response});
			var userExternalReferenceCodes = JSONUtil.getWithJSONPath(${response}, "$.studentUsers[*].externalReferenceCode");

			var response = CustomObjectAPI.updateObjectEntryAndRelatedObjectsByPut(
				alternateName = "user",
				emailDomain = "liferay.com",
				en_US_plural_label = "students",
				familyName = "userfn",
				fieldName = "name",
				fieldValue = "Bob-update",
				givenName = "usergn",
				nestedField = "studentUsers",
				objectEntryId = ${studentId},
				relatedUserAccount = "true",
				userExternalReferenceCodes = "${userExternalReferenceCodes},ercForNewUser");
		}

		task ("Then in response I can retrieve detailed information of the updated student and three users in studentUsers") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "Bob-update",
				objectJsonPath = "$.name",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "user1-update,user2-update,user3-update",
				objectJsonPath = "$.studentUsers[*].alternateName",
				response = ${response});
		}
	}

	@disable-webdriver = "true"
	@priority = 4
	test CanReturnUpdatedParentAndChildrenWithPutParentUserInOneToManyRelationship {
		property portal.acceptance = "true";

		task ("And Given with postUserAccount to create a user and two related students") {
			var response = UserAccountAPI.createUserAccountAndRelatedObjects(
				alternateName = "user",
				emailAddress = "user@liferay.com",
				familyName = "userfn",
				givenName = "usergn",
				nestedField = "userStudents",
				numberOfRelatedObjectEntries = 2,
				relatedEntryExternalReferenceCode = "studentErc",
				relatedEntryFieldName = "name");
		}

		task ("When with putUserAccount and userAccountId to update the existing user including userStudents with a new student and an existing student with its externalReferenceCode") {
			var userAccountId = JSONPathUtil.getIdValue(response = ${response});

			var response = UserAccountAPI.updateUserAccountAndRelatedObjects(
				alternateName = "user-update",
				emailAddress = "user-update@liferay.com",
				familyName = "userfn-update",
				givenName = "usergn-update",
				nestedField = "userStudents",
				numberOfRelatedObjectEntries = 3,
				relatedEntryExternalReferenceCode = "studentErc",
				relatedEntryFieldName = "name",
				userAccountId = ${userAccountId});
		}

		task ("Then in response I can retrieve detailed information of the updated user and students in userStudents") {
			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "user-update",
				objectJsonPath = "$.alternateName",
				response = ${response});

			CustomObjectAPI.assertCorrectObjectEntryValuesInResponse(
				expectedValues = "name0-update,name1-update,name2-update",
				objectJsonPath = "$.userStudents[*].name",
				response = ${response});
		}
	}

}